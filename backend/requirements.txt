# Core FastAPI dependencies
fastapi>=0.128.0
































































































































    return notification_manager    """Get the global notification manager instance"""def get_notification_manager() -> ConnectionManager:notification_manager = ConnectionManager()# Global connection manager instance        }            for user_type, connections in self.active_connections.items()            user_type: len(connections)        return {        """Get the number of active connections by user type"""    def get_connection_count(self) -> Dict[str, int]:            await self.send_personal_message(message, user_type, notification.recipient_id)                }            }                "metadata": json.loads(notification.metadata_json) if notification.metadata_json else None                "is_read": notification.is_read,                "created_at": notification.created_at.isoformat(),                "action_url": notification.action_url,                "priority": notification.priority,                "notification_type": notification.type.value,                "message": notification.message,                "title": notification.title,                "id": str(notification.id),            "data": {            "type": "notification",        message = {                    return        if not user_type:        user_type = user_type_mapping.get(notification.recipient_type)                }            RecipientTypeEnum.ADMIN: "admin"            RecipientTypeEnum.LAWYER: "lawyer",            RecipientTypeEnum.USER: "user",        user_type_mapping = {        """Send a notification via WebSocket"""    async def send_notification(self, notification: Notification):                    self.disconnect(user_type, user_id)            for user_id in disconnect_list:            # Remove broken connections                                disconnect_list.append(user_id)                    logger.error(f"Failed to broadcast to {user_type}:{user_id}: {e}")                except Exception as e:                    await websocket.send_text(json.dumps(message))                try:            for user_id, websocket in self.active_connections[user_type].items():                        disconnect_list = []        if user_type in self.active_connections:        """Broadcast message to all users of a specific type"""    async def broadcast_to_user_type(self, message: dict, user_type: str):                    self.disconnect(user_type, user_id)                # Remove the connection if it's broken                logger.error(f"Failed to send WebSocket message to {user_type}:{user_id}: {e}")            except Exception as e:                await websocket.send_text(json.dumps(message))                websocket = self.active_connections[user_type][user_id]            try:            user_id in self.active_connections[user_type]):        if (user_type in self.active_connections and         """Send message to a specific user"""    async def send_personal_message(self, message: dict, user_type: str, user_id: int):                logger.info(f"WebSocket disconnected: {user_type}:{user_id}")            del self.active_connections[user_type][user_id]            user_id in self.active_connections[user_type]):        if (user_type in self.active_connections and         """Remove a WebSocket connection"""    def disconnect(self, user_type: str, user_id: int):            }, user_type, user_id)            "message": "Real-time notifications enabled"            "type": "connection_established",        await self.send_personal_message({        # Send connection confirmation                logger.info(f"WebSocket connected: {user_type}:{user_id}")        self.active_connections[user_type][user_id] = websocket                        pass            except:                await self.active_connections[user_type][user_id].close()            try:        if user_id in self.active_connections[user_type]:        # Close any existing connection for this user                    self.active_connections[user_type] = {}        if user_type not in self.active_connections:        # Store the connection                await websocket.accept()        """Accept a new WebSocket connection"""    async def connect(self, websocket: WebSocket, user_type: str, user_id: int):            }            "admin": {}            "lawyer": {},            "user": {},        self.active_connections: Dict[str, Dict[int, WebSocket]] = {        # Store active connections by user type and ID    def __init__(self):        """Manages WebSocket connections for real-time notifications"""class ConnectionManager:logger = logging.getLogger(__name__)from datetime import datetimefrom models.notification import RecipientTypeEnum, Notificationfrom sqlalchemy.orm import Sessionfrom fastapi import WebSocket, WebSocketDisconnectfrom typing import Dict, List, Setimport loggingimport json"""Handles real-time notification delivery to frontend clientsuvicorn>=0.40.0
python-multipart>=0.0.9
itsdangerous>=2.1.2
websockets>=13.1

# Database
sqlalchemy>=2.0.46
psycopg2-binary>=2.9.9
alembic>=1.18.1

# Environment & Configuration
python-dotenv>=1.2.1
pydantic>=2.12.5
pydantic[email]>=2.12.5
pydantic-settings>=2.12.0

# Document Storage (S3/MinIO)
boto3>=1.42.36

# LangChain & AI
langchain>=1.2.7
langchain-openai>=1.1.7
langchain-core>=1.2.7
langchain-community>=0.2.0
langchain-google-genai>=1.0.0
langgraph>=1.0.7

# OpenAI
openai>=2.15.0
tiktoken>=0.12.0

# MCP (Model Context Protocol)
mcp>=1.26.0
fastmcp>=2.14.4

# Utilities
httpx>=0.28.1
requests>=2.32.5
pydantic-core>=2.41.5
typing-extensions>=4.15.0
typing-inspection>=0.4.2
email-validator>=2.3.0

# Authentication & Security
pyjwt>=2.10.1
cryptography>=46.0.4
argon2-cffi>=23.1.0
pyotp>=2.9.0
qrcode>=7.4.2
pillow>=10.2.0
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
python-multipart>=0.0.9

# Email
aiosmtplib>=3.0.1
jinja2>=3.1.3
sendgrid==6.11.0

# PDF Generation
weasyprint>=60.0
zipstream-ng>=1.7.0

# Rate Limiting
slowapi>=0.1.9

# User Agent Parsing (for session tracking)
user-agents>=2.2.0

# Monitoring & Observability
opentelemetry-api>=1.39.1
opentelemetry-sdk>=1.39.1
opentelemetry-instrumentation>=0.60b1
prometheus-client>=0.24.1

# Data Processing
jsonschema>=4.26.0
pyyaml>=6.0.3
ormsgpack>=1.12.1
orjson>=3.11.5

# Development
rich>=14.3.1

# Windows-specific (optional)
pywin32>=311; sys_platform == 'win32'